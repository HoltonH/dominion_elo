<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Dominion ELO Tracker</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 0;
      padding: 1.5rem;
      background: #0f172a;
      color: #e5e7eb;
    }

    h1, h2, h3 {
      margin: 0 0 0.75rem;
    }

    h1 {
      font-size: 1.75rem;
      margin-bottom: 1rem;
    }

    .container {
      max-width: 900px;
      margin: 0 auto;
    }

    .card {
      background: #020617;
      border-radius: 0.75rem;
      padding: 1rem 1.25rem;
      margin-bottom: 1rem;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.4);
      border: 1px solid #1f2937;
    }

    label {
      display: block;
      font-size: 0.85rem;
      margin-bottom: 0.25rem;
      color: #9ca3af;
    }

    input[type="text"],
    input[type="number"],
    input[type="date"],
    select {
      width: 100%;
      box-sizing: border-box;
      padding: 0.4rem 0.5rem;
      border-radius: 0.4rem;
      border: 1px solid #4b5563;
      background: #020617;
      color: #e5e7eb;
      font-size: 0.9rem;
      margin-bottom: 0.5rem;
    }

    input[type="number"] {
      max-width: 120px;
    }

    button {
      border: none;
      border-radius: 999px;
      padding: 0.4rem 0.9rem;
      font-size: 0.9rem;
      cursor: pointer;
      background: #4f46e5;
      color: white;
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
    }

    button.secondary {
      background: #111827;
      color: #e5e7eb;
      border: 1px solid #374151;
    }

    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .row {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      align-items: flex-end;
    }

    .row > .field {
      flex: 1 1 150px;
      min-width: 140px;
    }

    .field.inline {
      display: flex;
      flex-direction: column;
    }

    .small-text {
      font-size: 0.8rem;
      color: #9ca3af;
      margin-top: 0.25rem;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.9rem;
    }

    th, td {
      padding: 0.45rem 0.35rem;
      text-align: left;
    }

    th {
      border-bottom: 1px solid #374151;
      color: #9ca3af;
      font-weight: 500;
      white-space: nowrap;
    }

    tr:nth-child(even) {
      background: #020617;
    }

    tr:nth-child(odd) {
      background: #020617;
    }

    .rating {
      font-variant-numeric: tabular-nums;
    }

    .tag-pill {
      display: inline-block;
      padding: 0.1rem 0.5rem;
      border-radius: 999px;
      background: #111827;
      font-size: 0.75rem;
      color: #e5e7eb;
    }

    .pill-win {
      background: #16a34a33;
      color: #bbf7d0;
    }

    .pill-loss {
      background: #b91c1c33;
      color: #fecaca;
    }

    .game-players {
      font-size: 0.8rem;
      color: #9ca3af;
    }

    .flex-between {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    .badge {
      font-size: 0.75rem;
      padding: 0.1rem 0.5rem;
      border-radius: 999px;
      background: #111827;
      color: #9ca3af;
    }

    .danger {
      color: #fecaca;
    }

    /* Tabs for game history */
    .tabs {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-bottom: 0.5rem;
    }

    .tab {
      border-radius: 999px;
      padding: 0.25rem 0.7rem;
      font-size: 0.8rem;
      background: #111827;
      color: #9ca3af;
      border: 1px solid #374151;
      cursor: pointer;
    }

    .tab-active {
      background: #4f46e5;
      color: #ffffff;
      border-color: #4f46e5;
    }

    .tally-row {
      margin-top: 0.35rem;
      font-size: 0.9rem;
    }

    .tally-label {
      font-weight: 500;
      margin-right: 0.25rem;
    }

    .season-filter-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      align-items: center;
      margin-bottom: 0.5rem;
      font-size: 0.85rem;
    }

    .season-filter-row label {
      margin-bottom: 0;
    }

    .season-select {
      max-width: 180px;
    }

    .lifetime-table {
      margin-bottom: 0.75rem;
    }

    .lifetime-table table {
      font-size: 0.8rem;
    }

    .lifetime-table th,
    .lifetime-table td {
      padding: 0.25rem 0.3rem;
    }

    /* ELO chart */
    #eloChartWrapper {
      min-height: 180px;
    }

    @media (max-width: 600px) {
      body {
        padding: 0.75rem;
      }
      .card {
        padding: 0.75rem;
      }
      h1 {
        font-size: 1.4rem;
      }
    }
  </style>
  <!-- Chart.js for ELO over time chart -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
  <div class="container">
    <h1>Dominion ELO Tracker</h1>

    <!-- TOP SECTION: Log game -->
    <div class="card">
      <h2>Log game</h2>
      <div class="small-text" style="margin-bottom:0.5rem;">
        For 2 players, pick a winner and a loser. For 3 players, pick 1 winner and 2 losers.
        In 3-player games both losers are treated equally, and the winner gets a slightly larger ELO bump.
      </div>

      <div class="row">
        <div class="field inline" style="max-width:180px;">
          <label for="gameDate">Date</label>
          <input id="gameDate" type="date" />
        </div>
      </div>

      <div id="gamePlayersSection" style="margin-top:0.5rem;"></div>

      <div style="margin-top:0.75rem;">
        <button id="addGameBtn">+ Log game</button>
      </div>
    </div>

    <!-- TOP SECTION: Ratings -->
    <div class="card">
      <div class="flex-between">
        <h2>Ratings</h2>
        <span class="badge" id="gamesCountBadge">0 games logged</span>
      </div>
      <div id="ratingsTableWrapper"></div>
    </div>

    <!-- TOP SECTION: Game history -->
    <div class="card">
      <h2>Game history</h2>
      <!-- Season-aware win/loss record -->
      <div id="lifetimeRecord"></div>
      <!-- Season + tabs + content -->
      <div id="gamesTableWrapper" class="small-text">
        No games yet ‚Äì log your first one above.
      </div>
    </div>

    <!-- Players card -->
    <div class="card">
      <div class="flex-between">
        <h2>Players</h2>
        <span class="badge">Shared via Firebase Firestore (all of you see the same league)</span>
      </div>

      <div class="row">
        <div class="field">
          <label for="newPlayerName">Add player</label>
          <input id="newPlayerName" type="text" placeholder="e.g. Seymore" />
        </div>
        <div class="field inline" style="max-width:140px;">
          <label for="startingRating">Starting rating</label>
          <input id="startingRating" type="number" value="1500" />
        </div>
        <div class="field" style="flex:0 0 auto;">
          <button id="addPlayerBtn">+ Add</button>
        </div>
      </div>

      <div class="small-text">
        Tip: for ‚Äúme and 2 friends,‚Äù just add those 3 once and reuse them.
      </div>

      <div id="playersTableWrapper" style="margin-top:0.75rem;"></div>
    </div>

    <!-- Settings / K-factor -->
    <div class="card">
      <h2>Settings</h2>
      <div class="row">
        <div class="field inline" style="max-width:160px;">
          <label for="kFactor">Base K-factor</label>
          <input id="kFactor" type="number" value="32" min="1" max="100" />
          <div class="small-text">
            Used for 2-player games. 3-player games use 1.5√ó this K internally.
          </div>
        </div>
        <div class="field" style="flex:0 0 auto;">
          <button class="secondary" id="resetAllBtn">
            Reset all data
          </button>
        </div>
      </div>
      <div class="small-text">
        Reset all data wipes players, games, and settings from Firestore for this league.
      </div>
    </div>

    <!-- ELO over time chart -->
    <div class="card">
      <h2>ELO over time</h2>
      <div id="eloChartWrapper" class="small-text">
        ELO chart will appear after you log some games.
      </div>
    </div>
  </div>

  <!-- Main app logic + Firebase (module script) -->
  <script type="module">
    // ---------- Firebase imports (v12.6.0 CDN) ----------
    import { initializeApp } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-app.js";
    import {
      getFirestore,
      collection,
      doc,
      setDoc,
      addDoc,
      deleteDoc,
      getDocs,
      onSnapshot
    } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-firestore.js";

    // ---------- Firebase config (your real config) ----------
    const firebaseConfig = {
      apiKey: "AIzaSyALtVTPDkdpfI2c2A9K-At3MDWLJv4yVR0",
      authDomain: "dominion-elo.firebaseapp.com",
      projectId: "dominion-elo",
      storageBucket: "dominion-elo.firebasestorage.app",
      messagingSenderId: "923492313678",
      appId: "1:923492313678:web:d3b1d472c14fc5e0a9711f",
      measurementId: "G-QZ75F03RG3"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    // Firestore references
    const playersCol = collection(db, "players");
    const gamesCol = collection(db, "games");
    const settingsDocRef = doc(db, "settings", "global");

    // ---------- In-memory state ----------
    let players = [];  // { id, name, startingRating, rating }
    let games = [];    // { id, date, placements, participants }
    let settings = { kFactor: 32 };
    let currentHistoryTab = "all"; // 'all', 'three', or 'pair:ID1:ID2'
    let currentSeasonFilter = "all"; // 'all' or 'YYYY QX'

    // ELO timeline: one entry per game in chronological order
    // [{ date, ratings: { playerId: ratingAfterGame } }, ...]
    let ratingTimeline = [];
    let eloChartInstance = null;

    // ---------- Helpers ----------
    function getPlayerById(id) {
      return players.find(p => p.id === id);
    }

    function formatDate(dateStr) {
      if (!dateStr) return "";
      const d = new Date(dateStr);
      if (Number.isNaN(d.getTime())) return dateStr;
      return d.toLocaleDateString(undefined, {
        year: "numeric",
        month: "short",
        day: "numeric"
      });
    }

    // Season key: "YYYY Q1"..."YYYY Q4"
    function getSeasonKey(dateStr) {
      if (!dateStr) return "Unknown";
      const d = new Date(dateStr);
      if (Number.isNaN(d.getTime())) return "Unknown";
      const year = d.getFullYear();
      const month = d.getMonth(); // 0-based
      const quarter = Math.floor(month / 3) + 1;
      return `${year} Q${quarter}`;
    }

    // ELO calculation given a single game + current ratings
    // 2-player: normal base K
    // 3-player: winner vs each loser only, losers equal, K scaled by 1.5
    function calculateEloChanges(game, baseK) {
      const participants = game.participants.map(id => getPlayerById(id)).filter(Boolean);
      const deltas = {};
      participants.forEach(p => (deltas[p.id] = 0));

      const n = participants.length;
      const kFactor = n === 3 ? baseK * 1.5 : baseK;

      // Snapshot of ratings at game start
      const ratingsAtStart = {};
      participants.forEach(p => {
        ratingsAtStart[p.id] = p.rating;
      });

      for (let i = 0; i < participants.length; i++) {
        for (let j = i + 1; j < participants.length; j++) {
          const pA = participants[i];
          const pB = participants[j];

          const rA = ratingsAtStart[pA.id];
          const rB = ratingsAtStart[pB.id];

          const placementA = game.placements.find(pl => pl.playerId === pA.id);
          const placementB = game.placements.find(pl => pl.playerId === pB.id);

          const rankA = placementA ? placementA.rank : 2;
          const rankB = placementB ? placementB.rank : 2;

          // In 3-player game, if both are losers, skip (no loser-vs-loser match)
          if (n === 3 && rankA > 1 && rankB > 1) {
            continue;
          }

          let scoreA;
          if (rankA === rankB) {
            scoreA = 0.5;
          } else if (rankA < rankB) {
            scoreA = 1;
          } else {
            scoreA = 0;
          }
          const scoreB = 1 - scoreA;

          const expectedA = 1 / (1 + Math.pow(10, (rB - rA) / 400));
          const expectedB = 1 - expectedA;

          const deltaA = kFactor * (scoreA - expectedA);
          const deltaB = kFactor * (scoreB - expectedB);

          deltas[pA.id] += deltaA;
          deltas[pB.id] += deltaB;
        }
      }
      return deltas;
    }

    // Recalculate ratings from scratch based on players + games + settings
    // and build ratingTimeline
    function recalculateRatingsFromScratch() {
      players.forEach(p => {
        p.rating = p.startingRating || 1500;
      });

      ratingTimeline = [];

      const sortedGames = [...games].sort((a, b) => (a.date || "").localeCompare(b.date || ""));

      sortedGames.forEach(game => {
        const k = settings.kFactor || 32;
        const deltas = calculateEloChanges(game, k);
        Object.keys(deltas).forEach(playerId => {
          const player = getPlayerById(playerId);
          if (player) {
            player.rating += deltas[playerId];
          }
        });

        // snapshot ratings after this game
        const snapshot = {};
        players.forEach(p => {
          snapshot[p.id] = p.rating;
        });
        ratingTimeline.push({
          date: game.date,
          ratings: snapshot
        });
      });
    }

    // ---------- Season / lifetime record ----------
    function computeRecordForGames(gameList) {
      const records = {};
      players.forEach(p => {
        records[p.id] = { wins: 0, losses: 0 };
      });

      gameList.forEach(game => {
        const placementsSorted = [...game.placements].sort((a, b) => a.rank - b.rank);
        const winnerPlacement = placementsSorted.find(pl => pl.rank === 1);
        if (!winnerPlacement) return;
        const winnerId = winnerPlacement.playerId;

        if (!records[winnerId]) records[winnerId] = { wins: 0, losses: 0 };
        records[winnerId].wins += 1;

        placementsSorted.forEach(pl => {
          if (pl.playerId !== winnerId) {
            if (!records[pl.playerId]) records[pl.playerId] = { wins: 0, losses: 0 };
            records[pl.playerId].losses += 1;
          }
        });
      });

      return records;
    }

    function renderLifetimeRecord() {
      const container = document.getElementById("lifetimeRecord");
      if (!players.length) {
        container.innerHTML = '<div class="small-text">Lifetime record will appear after you add players and log some games.</div>';
        return;
      }

      let gameList;
      let labelText;

      if (currentSeasonFilter === "all") {
        gameList = games;
        labelText = "Lifetime win/loss (all seasons):";
      } else {
        gameList = games.filter(g => getSeasonKey(g.date) === currentSeasonFilter);
        labelText = `Win/loss for ${currentSeasonFilter}:`;
      }

      if (!gameList.length) {
        container.innerHTML = '<div class="small-text">No games in this season yet.</div>';
        return;
      }

      const records = computeRecordForGames(gameList);
      const rows = players.map(p => {
        const r = records[p.id] || { wins: 0, losses: 0 };
        const total = r.wins + r.losses;
        const winPct = total ? ((r.wins / total) * 100).toFixed(1) : "‚Äî";
        return {
          name: p.name,
          wins: r.wins,
          losses: r.losses,
          winPct,
          total
        };
      });

      rows.sort((a, b) => {
        if (b.wins !== a.wins) return b.wins - a.wins;
        return a.losses - b.losses;
      });

      let html = '<div class="lifetime-table small-text">';
      html += `<div style='margin-bottom:0.25rem;'>${labelText}</div>`;
      html += "<table><thead><tr><th>Player</th><th>W</th><th>L</th><th>Win%</th></tr></thead><tbody>";
      rows.forEach(r => {
        html += `<tr>
          <td>${r.name}</td>
          <td>${r.wins}</td>
          <td>${r.losses}</td>
          <td>${r.winPct === "‚Äî" ? "‚Äî" : r.winPct + "%"}</td>
        </tr>`;
      });
      html += "</tbody></table></div>";

      container.innerHTML = html;
    }

    // ---------- Rendering: players ----------
    function renderPlayersTable() {
      const wrapper = document.getElementById("playersTableWrapper");
      if (!players.length) {
        wrapper.innerHTML = '<div class="small-text">Add players above to get started.</div>';
        return;
      }

      const sorted = [...players].sort((a, b) => (b.rating || 0) - (a.rating || 0));
      const leaderId = sorted.length ? sorted[0].id : null;

      let html = "<table><thead><tr>";
      html += "<th>Name</th><th>Rating</th><th>Games</th><th></th></tr></thead><tbody>";

      sorted.forEach(p => {
        const numGames = games.filter(g => g.participants.includes(p.id)).length;
        const displayName = p.id === leaderId ? `üëë ${p.name}` : p.name;
        html += `<tr>
          <td>${displayName}</td>
          <td class="rating">${Math.round(p.rating)}</td>
          <td>${numGames}</td>
          <td><button class="secondary" data-remove-player="${p.id}">Remove</button></td>
        </tr>`;
      });

      html += "</tbody></table>";
      wrapper.innerHTML = html;

      wrapper.querySelectorAll("button[data-remove-player]").forEach(btn => {
        btn.addEventListener("click", async () => {
          const id = btn.getAttribute("data-remove-player");
          if (!confirm("Remove this player from Firestore? Their existing games will still reference them.")) {
            return;
          }
          await deleteDoc(doc(db, "players", id));
        });
      });
    }

    // ---------- Rendering: ratings ----------
    function renderRatingsTable() {
      const wrapper = document.getElementById("ratingsTableWrapper");
      if (!players.length) {
        wrapper.innerHTML = '<div class="small-text">No players yet.</div>';
        return;
      }

      const sorted = [...players].sort((a, b) => (b.rating || 0) - (a.rating || 0));
      const leaderId = sorted.length ? sorted[0].id : null;

      let html = "<table><thead><tr>";
      html += "<th>#</th><th>Name</th><th>Rating</th><th>Games</th></tr></thead><tbody>";

      sorted.forEach((p, idx) => {
        const numGames = games.filter(g => g.participants.includes(p.id)).length;
        const displayName = p.id === leaderId ? `üëë ${p.name}` : p.name;
        html += `<tr>
          <td>${idx + 1}</td>
          <td>${displayName}</td>
          <td class="rating">${Math.round(p.rating)}</td>
          <td>${numGames}</td>
        </tr>`;
      });

      html += "</tbody></table>";
      wrapper.innerHTML = html;
    }

    // ---------- Rendering: log-game form ----------
    function renderGamePlayersForm() {
      const section = document.getElementById("gamePlayersSection");
      if (players.length < 2) {
        section.innerHTML = '<div class="small-text danger">You need at least 2 players to log a game.</div>';
        return;
      }

      const playerOptions = players
        .map(p => `<option value="${p.id}">${p.name}</option>`)
        .join("");

      section.innerHTML = `
        <div class="row">
          <div class="field">
            <label>Winner</label>
            <select id="slotWinner">
              <option value="">-- select winner --</option>
              ${playerOptions}
            </select>
          </div>
          <div class="field">
            <label>Loser 1</label>
            <select id="slotLoser1">
              <option value="">-- select loser --</option>
              ${playerOptions}
            </select>
          </div>
          <div class="field">
            <label>Loser 2 (optional)</label>
            <select id="slotLoser2">
              <option value="">-- none --</option>
              ${playerOptions}
            </select>
          </div>
        </div>
        <div class="small-text">
          2-player game: pick a Winner and a single Loser 1.<br/>
          3-player game: pick a Winner and both Loser 1 and Loser 2.
        </div>
      `;
    }

    // ---------- Rendering: history helpers ----------

    function buildAllGamesTableHtml(filteredGames) {
      if (!filteredGames.length) {
        return '<div class="small-text">No games in this season yet.</div>';
      }

      const sorted = [...filteredGames].sort((a, b) => {
        const da = a.date || "";
        const db = b.date || "";
        return db.localeCompare(da);
      });

      let html = "<table><thead><tr>";
      html += "<th>Date</th><th>Result</th><th>Players</th><th></th></tr></thead><tbody>";

      sorted.forEach(game => {
        const placementsSorted = [...game.placements].sort((a, b) => a.rank - b.rank);

        const winnerPlacement = placementsSorted.find(pl => pl.rank === 1);
        const winnerPlayer = winnerPlacement ? getPlayerById(winnerPlacement.playerId) : null;
        const winnerName = winnerPlayer ? winnerPlayer.name : "Unknown";

        const losers = placementsSorted.filter(pl => pl.rank > 1);
        const playersListHtml = [
          winnerPlayer ? `üèÜ ${winnerPlayer.name}` : null,
          ...losers.map(pl => {
            const p = getPlayerById(pl.playerId);
            return p ? `üíÄ ${p.name}` : null;
          })
        ]
          .filter(Boolean)
          .join("<br/>");

        html += `<tr>
          <td>${formatDate(game.date)}</td>
          <td><span class="tag-pill pill-win">Winner: ${winnerName}</span></td>
          <td class="game-players">${playersListHtml}</td>
          <td><button class="secondary" data-delete-game="${game.id}">Delete</button></td>
        </tr>`;
      });

      html += "</tbody></table>";
      return html;
    }

    function buildHeadToHeadHtml(playerAId, playerBId, filteredGames) {
      const playerA = getPlayerById(playerAId);
      const playerB = getPlayerById(playerBId);
      if (!playerA || !playerB) {
        return '<div class="small-text">Players not found.</div>';
      }

      const relevantGames = filteredGames.filter(
        g => g.participants.includes(playerAId) && g.participants.includes(playerBId)
      );

      if (!relevantGames.length) {
        return `<div class="small-text">No games with both ${playerA.name} and ${playerB.name} in this season.</div>`;
      }

      let winsA = 0;
      let winsB = 0;

      relevantGames.forEach(game => {
        const plA = game.placements.find(pl => pl.playerId === playerAId);
        const plB = game.placements.find(pl => pl.playerId === playerBId);
        if (!plA || !plB) return;

        const rankA = plA.rank;
        const rankB = plB.rank;

        if (rankA < rankB) {
          winsA++;
        } else if (rankB < rankA) {
          winsB++;
        }
        // if equal (both losers), don't count
      });

      let html = `<div class="small-text">Games with both players in this season: ${relevantGames.length}</div>`;
      html += `<div class="tally-row">
        <span class="tally-label">${playerA.name} wins:</span>
        <span>${winsA}</span>
      </div>`;
      html += `<div class="tally-row">
        <span class="tally-label">${playerB.name} wins:</span>
        <span>${winsB}</span>
      </div>`;

      return html;
    }

    function buildThreePlayerStatsHtml(filteredGames) {
      const threePlayerGames = filteredGames.filter(g => g.participants.length === 3);

      if (!threePlayerGames.length) {
        return '<div class="small-text">No 3-player games in this season.</div>';
      }

      const winCounts = {};
      players.forEach(p => {
        winCounts[p.id] = 0;
      });

      threePlayerGames.forEach(game => {
        const winnerPlacement = game.placements.find(pl => pl.rank === 1);
        if (!winnerPlacement) return;
        if (winCounts[winnerPlacement.playerId] === undefined) {
          winCounts[winnerPlacement.playerId] = 0;
        }
        winCounts[winnerPlacement.playerId]++;
      });

      let html = `<div class="small-text">Total 3-player games this season: ${threePlayerGames.length}</div>`;

      players.forEach(p => {
        const wins = winCounts[p.id] || 0;
        html += `<div class="tally-row">
          <span class="tally-label">${p.name} 3-player wins:</span>
          <span>${wins}</span>
        </div>`;
      });

      return html;
    }

    // ---------- Rendering: history with seasons + tabs ----------
    function renderHistory() {
      const wrapper = document.getElementById("gamesTableWrapper");
      const gamesCountBadge = document.getElementById("gamesCountBadge");
      gamesCountBadge.textContent = `${games.length} game${games.length === 1 ? "" : "s"} logged`;

      if (!games.length) {
        wrapper.innerHTML = '<div class="small-text">No games yet ‚Äì log your first one above.</div>';
        return;
      }

      // Build list of seasons present
      const seasonSet = new Set();
      games.forEach(g => {
        const key = getSeasonKey(g.date);
        seasonSet.add(key);
      });
      const seasons = Array.from(seasonSet).sort();

      // Filtered games by season
      const filteredGames =
        currentSeasonFilter === "all"
          ? games
          : games.filter(g => getSeasonKey(g.date) === currentSeasonFilter);

      // Build season selector + tabs container
      let html = "";

      // Season filter row
      html += '<div class="season-filter-row">';
      html += '<label for="seasonFilter">Season:</label>';
      html += '<select id="seasonFilter" class="season-select">';
      html += `<option value="all"${currentSeasonFilter === "all" ? " selected" : ""}>All seasons</option>`;
      seasons.forEach(seasonKey => {
        html += `<option value="${seasonKey}"${
          currentSeasonFilter === seasonKey ? " selected" : ""
        }>${seasonKey}</option>`;
      });
      html += "</select>";
      if (currentSeasonFilter === "all") {
        html += '<span class="small-text">Showing all games.</span>';
      } else {
        html += `<span class="small-text">Showing games for ${currentSeasonFilter}.</span>`;
      }
      html += "</div>";

      if (!filteredGames.length) {
        html += '<div class="small-text">No games in this season yet.</div>';
        wrapper.innerHTML = html;

        // attach change handler for season filter
        const select = wrapper.querySelector("#seasonFilter");
        if (select) {
          select.addEventListener("change", () => {
            currentSeasonFilter = select.value;
            renderLifetimeRecord();
            renderHistory();
          });
        }
        return;
      }

      // Build tab definitions
      const tabs = [];
      tabs.push({ id: "all", label: "All games" });

      const pairTabs = [];
      for (let i = 0; i < players.length; i++) {
        for (let j = i + 1; j < players.length; j++) {
          const pA = players[i];
          const pB = players[j];
          pairTabs.push({
            id: `pair:${pA.id}:${pB.id}`,
            label: `${pA.name} vs ${pB.name}`,
            aId: pA.id,
            bId: pB.id
          });
        }
      }
      tabs.push(...pairTabs);

      const hasThreePlayer = filteredGames.some(g => g.participants.length === 3);
      if (hasThreePlayer) {
        tabs.push({ id: "three", label: "3-player games" });
      }

      if (!tabs.find(t => t.id === currentHistoryTab)) {
        currentHistoryTab = "all";
      }

      // Tabs HTML
      html += '<div class="tabs">';
      tabs.forEach(t => {
        const activeClass = t.id === currentHistoryTab ? "tab-active" : "";
        html += `<button class="tab ${activeClass}" data-tab-id="${t.id}">${t.label}</button>`;
      });
      html += '</div><div id="historyInner"></div>';

      wrapper.innerHTML = html;

      // Season filter listener
      const select = wrapper.querySelector("#seasonFilter");
      if (select) {
        select.addEventListener("change", () => {
          currentSeasonFilter = select.value;
          renderLifetimeRecord();
          renderHistory();
        });
      }

      // Tab listeners
      wrapper.querySelectorAll(".tab").forEach(btn => {
        btn.addEventListener("click", () => {
          const tabId = btn.getAttribute("data-tab-id");
          currentHistoryTab = tabId;
          renderHistory();
        });
      });

      // Render tab content
      const inner = document.getElementById("historyInner");
      if (!inner) return;

      if (currentHistoryTab === "all") {
        inner.innerHTML = buildAllGamesTableHtml(filteredGames);
        inner.querySelectorAll("button[data-delete-game]").forEach(btn => {
          btn.addEventListener("click", async () => {
            const id = btn.getAttribute("data-delete-game");
            if (!confirm("Delete this game from Firestore? Ratings will be recalculated.")) {
              return;
            }
            await deleteDoc(doc(db, "games", id));
          });
        });
      } else if (currentHistoryTab === "three") {
        inner.innerHTML = buildThreePlayerStatsHtml(filteredGames);
      } else if (currentHistoryTab.startsWith("pair:")) {
        const parts = currentHistoryTab.split(":");
        const aId = parts[1];
        const bId = parts[2];
        inner.innerHTML = buildHeadToHeadHtml(aId, bId, filteredGames);
      }
    }

    // ---------- ELO chart ----------
    function renderEloChart() {
      const wrapper = document.getElementById("eloChartWrapper");
      if (!wrapper) return;

      if (!games.length || !ratingTimeline.length || !players.length) {
        wrapper.innerHTML = '<div class="small-text">ELO chart will appear after you log some games.</div>';
        if (eloChartInstance) {
          eloChartInstance.destroy();
          eloChartInstance = null;
        }
        return;
      }

      // Build labels (per game)
      const labels = ratingTimeline.map(pt => formatDate(pt.date));

      // One dataset per player
      const datasets = players.map(p => {
        const data = ratingTimeline.map(pt =>
          pt.ratings[p.id] !== undefined ? Math.round(pt.ratings[p.id]) : null
        );
        return {
          label: p.name,
          data,
          borderWidth: 2,
          tension: 0.2,
          spanGaps: true
        };
      });

      wrapper.innerHTML = '<canvas id="eloChartCanvas"></canvas>';
      const ctx = document.getElementById("eloChartCanvas").getContext("2d");

      if (eloChartInstance) {
        eloChartInstance.destroy();
      }

      eloChartInstance = new Chart(ctx, {
        type: "line",
        data: {
          labels,
          datasets
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              title: {
                display: true,
                text: "ELO rating"
              }
            },
            x: {
              title: {
                display: true,
                text: "Game"
              }
            }
          },
          plugins: {
            legend: {
              display: true,
              labels: {
                boxWidth: 12
              }
            }
          }
        }
      });
    }

    // ---------- Render all ----------
    function renderAll() {
      renderPlayersTable();
      renderRatingsTable();
      renderGamePlayersForm();
      renderLifetimeRecord();
      renderHistory();
      renderEloChart();

      const kInput = document.getElementById("kFactor");
      if (kInput) {
        kInput.value = settings.kFactor || 32;
      }
    }

    // ---------- Firestore subscriptions ----------
    function subscribeToFirestore() {
      // Players
      onSnapshot(playersCol, snapshot => {
        players = snapshot.docs.map(docSnap => ({
          id: docSnap.id,
          ...docSnap.data()
        }));
        recalculateRatingsFromScratch();
        renderAll();
      });

      // Games
      onSnapshot(gamesCol, snapshot => {
        games = snapshot.docs.map(docSnap => ({
          id: docSnap.id,
          ...docSnap.data()
        }));
        recalculateRatingsFromScratch();
        renderAll();
      });

      // Settings (single doc)
      onSnapshot(settingsDocRef, async docSnap => {
        if (!docSnap.exists()) {
          await setDoc(settingsDocRef, { kFactor: 32 });
          settings = { kFactor: 32 };
        } else {
          settings = { kFactor: docSnap.data().kFactor ?? 32 };
        }
        recalculateRatingsFromScratch();
        renderAll();
      });
    }

    // ---------- Reset all data ----------
    async function resetAllData() {
      if (!confirm("This will delete ALL players, games, and settings from Firestore. Continue?")) {
        return;
      }

      const playersSnap = await getDocs(playersCol);
      await Promise.all(playersSnap.docs.map(d => deleteDoc(d.ref)));

      const gamesSnap = await getDocs(gamesCol);
      await Promise.all(gamesSnap.docs.map(d => deleteDoc(d.ref)));

      await setDoc(settingsDocRef, { kFactor: 32 });
    }

    // ---------- Event wiring ----------
    function setupEventHandlers() {
      const addPlayerBtn = document.getElementById("addPlayerBtn");
      const newPlayerNameInput = document.getElementById("newPlayerName");
      const startingRatingInput = document.getElementById("startingRating");
      const addGameBtn = document.getElementById("addGameBtn");
      const kFactorInput = document.getElementById("kFactor");
      const resetAllBtn = document.getElementById("resetAllBtn");
      const gameDateInput = document.getElementById("gameDate");

      // Default date to today
      if (gameDateInput) {
        const today = new Date().toISOString().slice(0, 10);
        gameDateInput.value = today;
      }

      if (addPlayerBtn) {
        addPlayerBtn.addEventListener("click", async () => {
          const name = newPlayerNameInput.value.trim();
          let rating = Number(startingRatingInput.value);
          if (!name) {
            alert("Enter a player name.");
            return;
          }
          if (!Number.isFinite(rating)) rating = 1500;

          await addDoc(playersCol, {
            name,
            startingRating: rating
          });

          newPlayerNameInput.value = "";
        });
      }

      if (kFactorInput) {
        kFactorInput.addEventListener("change", async () => {
          let k = Number(kFactorInput.value);
          if (!Number.isFinite(k) || k <= 0) k = 32;
          await setDoc(settingsDocRef, { kFactor: k }, { merge: true });
        });
      }

      if (resetAllBtn) {
        resetAllBtn.addEventListener("click", () => {
          resetAllData();
        });
      }

      if (addGameBtn) {
        addGameBtn.addEventListener("click", async () => {
          const dateInput = document.getElementById("gameDate");
          const date = dateInput.value || new Date().toISOString().slice(0, 10);

          const winnerSel = document.getElementById("slotWinner");
          const loser1Sel = document.getElementById("slotLoser1");
          const loser2Sel = document.getElementById("slotLoser2");

          const winnerId = winnerSel.value;
          const loser1Id = loser1Sel.value;
          const loser2Id = loser2Sel.value;

          if (!winnerId || !loser1Id) {
            alert("You need at least a winner and one loser.");
            return;
          }

          const chosen = [winnerId, loser1Id, loser2Id].filter(Boolean);
          const unique = new Set(chosen);
          if (unique.size !== chosen.length) {
            alert("Each slot must be a different player.");
            return;
          }

          const placements = [
            { playerId: winnerId, rank: 1 },
            { playerId: loser1Id, rank: 2 }
          ];
          if (loser2Id) placements.push({ playerId: loser2Id, rank: 2 });

          const participants = placements.map(pl => pl.playerId);

          const game = {
            date,
            placements,
            participants
          };

          await addDoc(gamesCol, game);
        });
      }
    }

    // ---------- Init ----------
    document.addEventListener("DOMContentLoaded", () => {
      setupEventHandlers();
      subscribeToFirestore();
    });
  </script>
</body>
</html>
