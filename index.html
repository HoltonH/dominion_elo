<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Dominion ELO Tracker</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 0;
      padding: 1.5rem;
      background: #0f172a;
      color: #e5e7eb;
    }

    h1, h2, h3 {
      margin: 0 0 0.75rem;
    }

    h1 {
      font-size: 1.75rem;
      margin-bottom: 1rem;
    }

    .container {
      max-width: 900px;
      margin: 0 auto;
    }

    .card {
      background: #020617;
      border-radius: 0.75rem;
      padding: 1rem 1.25rem;
      margin-bottom: 1rem;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.4);
      border: 1px solid #1f2937;
    }

    label {
      display: block;
      font-size: 0.85rem;
      margin-bottom: 0.25rem;
      color: #9ca3af;
    }

    input[type="text"],
    input[type="number"],
    input[type="date"],
    select {
      width: 100%;
      box-sizing: border-box;
      padding: 0.4rem 0.5rem;
      border-radius: 0.4rem;
      border: 1px solid #4b5563;
      background: #020617;
      color: #e5e7eb;
      font-size: 0.9rem;
      margin-bottom: 0.5rem;
    }

    input[type="number"] {
      max-width: 160px;
    }

    button {
      border: none;
      border-radius: 999px;
      padding: 0.4rem 0.9rem;
      font-size: 0.9rem;
      cursor: pointer;
      background: #4f46e5;
      color: white;
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
    }

    button.secondary {
      background: #111827;
      color: #e5e7eb;
      border: 1px solid #374151;
    }

    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .row {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      align-items: flex-end;
    }

    .row > .field {
      flex: 1 1 150px;
      min-width: 140px;
    }

    .field.inline {
      display: flex;
      flex-direction: column;
    }

    .small-text {
      font-size: 0.8rem;
      color: #9ca3af;
      margin-top: 0.25rem;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.9rem;
    }

    th, td {
      padding: 0.45rem 0.35rem;
      text-align: left;
    }

    th {
      border-bottom: 1px solid #374151;
      color: #9ca3af;
      font-weight: 500;
      white-space: nowrap;
    }

    .rating {
      font-variant-numeric: tabular-nums;
    }

    .tag-pill {
      display: inline-block;
      padding: 0.1rem 0.5rem;
      border-radius: 999px;
      background: #111827;
      font-size: 0.75rem;
      color: #e5e7eb;
    }

    .pill-win {
      background: #16a34a33;
      color: #bbf7d0;
    }

    .game-players {
      font-size: 0.8rem;
      color: #9ca3af;
    }

    .flex-between {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    .badge {
      font-size: 0.75rem;
      padding: 0.1rem 0.5rem;
      border-radius: 999px;
      background: #111827;
      color: #9ca3af;
    }

    .danger {
      color: #fecaca;
    }

    /* Tabs */
    .tabs {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-bottom: 0.5rem;
    }

    .tab {
      border-radius: 999px;
      padding: 0.25rem 0.7rem;
      font-size: 0.8rem;
      background: #111827;
      color: #9ca3af;
      border: 1px solid #374151;
      cursor: pointer;
    }

    .tab-active {
      background: #4f46e5;
      color: #ffffff;
      border-color: #4f46e5;
    }

    .tally-row {
      margin-top: 0.35rem;
      font-size: 0.9rem;
    }

    .tally-label {
      font-weight: 500;
      margin-right: 0.25rem;
    }

    .season-filter-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      align-items: center;
      margin-bottom: 0.5rem;
      font-size: 0.85rem;
    }

    .season-filter-row label {
      margin-bottom: 0;
    }

    .season-select {
      max-width: 180px;
    }

    .record-table {
      margin-bottom: 0.75rem;
    }

    .record-table table {
      font-size: 0.8rem;
    }

    .record-table th,
    .record-table td {
      padding: 0.25rem 0.3rem;
    }

    /* ELO chart */
    #eloChartWrapper {
      min-height: 180px;
    }

    /* Admin dropdown */
    details.admin {
      margin-top: 1rem;
    }
    details.admin > summary {
      list-style: none;
      cursor: pointer;
      user-select: none;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.75rem;
      font-weight: 600;
    }
    details.admin > summary::-webkit-details-marker {
      display: none;
    }
    .chev {
      font-size: 0.9rem;
      color: #9ca3af;
    }
    details.admin[open] .chev {
      transform: rotate(180deg);
      display: inline-block;
    }
    .admin-grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 1rem;
      margin-top: 0.75rem;
    }
    @media (min-width: 800px) {
      .admin-grid {
        grid-template-columns: 1fr 1fr;
      }
    }

    @media (max-width: 600px) {
      body { padding: 0.75rem; }
      .card { padding: 0.75rem; }
      h1 { font-size: 1.4rem; }
    }
  </style>

  <!-- Chart.js (for weekly ELO chart) -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>

<body>
  <div class="container">
    <h1>Dominion ELO Tracker</h1>
<img
  src="./ChatGPT Image Dec 27, 2025, 03_15_07 PM.png"
  alt="Dominion ELO logo"
  style="width:100%; max-height:220px; object-fit:contain; border-radius:12px; margin: 0 0 1rem;"
/>

    <!-- Log game -->
    <div class="card">
      <h2>Log game</h2>
      <div class="small-text" style="margin-bottom:0.5rem;">
        2-player games use Winner/Loser. 3-player games use 1st/2nd/3rd.
        Head-to-head tabs only count pure 2-player games.
      </div>

      <div class="row">
        <div class="field inline" style="max-width:180px;">
          <label for="gameDate">Date</label>
          <input id="gameDate" type="date" />
        </div>
      </div>

      <div id="gamePlayersSection" style="margin-top:0.5rem;"></div>

      <div style="margin-top:0.75rem;">
        <button id="addGameBtn">+ Log game</button>
      </div>
    </div>

    <!-- Ratings -->
    <div class="card">
      <div class="flex-between">
        <h2>Ratings</h2>
        <span class="badge" id="gamesCountBadge">0 games logged</span>
      </div>
      <div id="ratingsTableWrapper"></div>
    </div>

    <!-- ELO chart moved directly below Ratings -->
    <div class="card">
      <h2>ELO over time (weekly)</h2>
      <div id="eloChartWrapper" class="small-text">
        ELO chart will appear after you log some games.
      </div>
    </div>

    <!-- Game history -->
    <div class="card">
      <h2>Game history</h2>
      <div id="recordBlock"></div>
      <div id="gamesTableWrapper" class="small-text">
        No games yet ‚Äì log your first one above.
      </div>
    </div>

    <!-- Admin dropdown at bottom: Players + Settings -->
    <div class="card">
      <details class="admin">
        <summary>
          <span>League settings & players</span>
          <span class="chev">‚ñæ</span>
        </summary>

        <div class="admin-grid">
          <!-- Players panel -->
          <div>
            <h3 style="margin-top:0;">Players</h3>

            <div class="row">
              <div class="field">
                <label for="newPlayerName">Add player</label>
                <input id="newPlayerName" type="text" placeholder="e.g. Seymore" />
              </div>
              <div class="field inline" style="max-width:160px;">
                <label for="startingRating">Starting rating</label>
                <input id="startingRating" type="number" value="1500" />
              </div>
              <div class="field" style="flex:0 0 auto;">
                <button id="addPlayerBtn">+ Add</button>
              </div>
            </div>

            <div class="small-text">Add your three names once and reuse them.</div>
            <div id="playersTableWrapper" style="margin-top:0.75rem;"></div>
          </div>

          <!-- Settings panel -->
          <div>
            <h3 style="margin-top:0;">Settings</h3>

            <div class="row">
              <div class="field inline" style="max-width:220px;">
                <label for="kFactor">Base K-factor</label>
                <input id="kFactor" type="number" value="32" min="1" max="100" />
                <div class="small-text">
                  Used for 2-player games. 3-player games use a mild bump (1.25√ó) internally.
                </div>
              </div>

              <div class="field" style="flex:0 0 auto;">
                <button class="secondary" id="resetAllBtn">Reset all data</button>
              </div>
            </div>

            <div class="small-text danger">
              Reset wipes players, games, and settings from Firestore for this league.
            </div>
          </div>
        </div>
      </details>
    </div>
  </div>

  <script type="module">
    // ---------- Firebase imports (v12.6.0 CDN) ----------
    import { initializeApp } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-app.js";
    import {
      getFirestore,
      collection,
      doc,
      setDoc,
      addDoc,
      deleteDoc,
      getDocs,
      onSnapshot
    } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-firestore.js";

    // ---------- Firebase config ----------
    const firebaseConfig = {
      apiKey: "AIzaSyALtVTPDkdpfI2c2A9K-At3MDWLJv4yVR0",
      authDomain: "dominion-elo.firebaseapp.com",
      projectId: "dominion-elo",
      storageBucket: "dominion-elo.firebasestorage.app",
      messagingSenderId: "923492313678",
      appId: "1:923492313678:web:d3b1d472c14fc5e0a9711f",
      measurementId: "G-QZ75F03RG3"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    const playersCol = collection(db, "players");
    const gamesCol = collection(db, "games");
    const settingsDocRef = doc(db, "settings", "global");

    // ---------- State ----------
    let players = [];     // { id, name, startingRating, rating }
    let games = [];       // { id, date, placements, participants }
    let settings = { kFactor: 32 };

    let currentHistoryTab = "all";       // 'all', 'three', or 'pair:ID1:ID2'
    let currentSeasonFilter = "all";     // 'all' or 'YYYY QX'

    // ratingTimeline: after each game snapshot
    let ratingTimeline = []; // [{ date, ratings: {playerId: rating} }]
    let eloChartInstance = null;

    // ---------- Helpers ----------
    function getPlayerById(id) {
      return players.find(p => p.id === id);
    }

    function formatDate(dateStr) {
      if (!dateStr) return "";
      const d = new Date(dateStr);
      if (Number.isNaN(d.getTime())) return dateStr;
      return d.toLocaleDateString(undefined, { year: "numeric", month: "short", day: "numeric" });
    }

    // Quarter season: "YYYY Q1..Q4"
    function getSeasonKey(dateStr) {
      if (!dateStr) return "Unknown";
      const d = new Date(dateStr);
      if (Number.isNaN(d.getTime())) return "Unknown";
      const year = d.getFullYear();
      const quarter = Math.floor(d.getMonth() / 3) + 1;
      return `${year} Q${quarter}`;
    }

    // Weekly bucketing for chart: week starts Monday
    function getWeekKeyAndLabel(dateStr) {
      const d = new Date(dateStr);
      if (Number.isNaN(d.getTime())) {
        return { key: dateStr || "Unknown", label: formatDate(dateStr) };
      }
      const day = d.getDay();           // 0=Sun..6=Sat
      const diffToMonday = (day + 6) % 7;
      const monday = new Date(d);
      monday.setDate(d.getDate() - diffToMonday);
      const key = monday.toISOString().slice(0, 10);
      return { key, label: formatDate(key) };
    }

    // ---------- ELO ----------
    // 2-player: standard Elo
    // 3-player: 1st/2nd/3rd -> pairwise, but soften 2v3 so 3rd loses a bit more (not too much)
    function calculateEloChanges(game, baseK) {
      const participants = game.participants.map(id => getPlayerById(id)).filter(Boolean);
      const deltas = {};
      participants.forEach(p => (deltas[p.id] = 0));

      const n = participants.length;
      const kFactor = n === 3 ? baseK * 1.25 : baseK;

      const ratingsAtStart = {};
      participants.forEach(p => (ratingsAtStart[p.id] = p.rating));

      function getRank(pid) {
        const pl = game.placements.find(x => x.playerId === pid);
        return pl ? pl.rank : 999;
      }

      function pairWeight(rankA, rankB) {
        if (n !== 3) return 1;
        const a = Math.min(rankA, rankB);
        const b = Math.max(rankA, rankB);
        if (a === 2 && b === 3) return 0.6; // tweak knob (0.5‚Äì0.8 feels good)
        return 1;
      }

      for (let i = 0; i < participants.length; i++) {
        for (let j = i + 1; j < participants.length; j++) {
          const pA = participants[i];
          const pB = participants[j];

          const rA = ratingsAtStart[pA.id];
          const rB = ratingsAtStart[pB.id];

          const rankA = getRank(pA.id);
          const rankB = getRank(pB.id);

          let scoreA;
          if (rankA === rankB) scoreA = 0.5;
          else if (rankA < rankB) scoreA = 1;
          else scoreA = 0;

          const scoreB = 1 - scoreA;

          const expectedA = 1 / (1 + Math.pow(10, (rB - rA) / 400));
          const expectedB = 1 - expectedA;

          const w = pairWeight(rankA, rankB);

          const deltaA = w * kFactor * (scoreA - expectedA);
          const deltaB = w * kFactor * (scoreB - expectedB);

          deltas[pA.id] += deltaA;
          deltas[pB.id] += deltaB;
        }
      }

      return deltas;
    }

    // recompute ratings + build per-game rating timeline
    function recalculateRatingsFromScratch() {
      players.forEach(p => { p.rating = p.startingRating || 1500; });
      ratingTimeline = [];

      const sortedGames = [...games].sort((a, b) => (a.date || "").localeCompare(b.date || ""));
      sortedGames.forEach(game => {
        const k = settings.kFactor ?? 32;
        const deltas = calculateEloChanges(game, k);

        Object.keys(deltas).forEach(pid => {
          const pl = getPlayerById(pid);
          if (pl) pl.rating += deltas[pid];
        });

        const snapshot = {};
        players.forEach(p => snapshot[p.id] = p.rating);
        ratingTimeline.push({ date: game.date, ratings: snapshot });
      });
    }

    // ---------- Records ----------
    function computeRecordForGames(gameList) {
      const records = {};
      players.forEach(p => records[p.id] = { wins: 0, losses: 0 });

      gameList.forEach(game => {
        const placementsSorted = [...game.placements].sort((a, b) => a.rank - b.rank);
        const winner = placementsSorted.find(pl => pl.rank === 1);
        if (!winner) return;

        records[winner.playerId].wins += 1;

        placementsSorted.forEach(pl => {
          if (pl.playerId !== winner.playerId) records[pl.playerId].losses += 1;
        });
      });

      return records;
    }

    function renderRecordBlock() {
      const container = document.getElementById("recordBlock");
      if (!players.length) {
        container.innerHTML = '<div class="small-text">Win/loss will appear after you add players and log games.</div>';
        return;
      }

      let gameList, labelText;
      if (currentSeasonFilter === "all") {
        gameList = games;
        labelText = "Lifetime win/loss (all seasons):";
      } else {
        gameList = games.filter(g => getSeasonKey(g.date) === currentSeasonFilter);
        labelText = `Win/loss for ${currentSeasonFilter}:`;
      }

      if (!gameList.length) {
        container.innerHTML = '<div class="small-text">No games in this season yet.</div>';
        return;
      }

      const records = computeRecordForGames(gameList);

      const rows = players.map(p => {
        const r = records[p.id] || { wins: 0, losses: 0 };
        const total = r.wins + r.losses;
        const winPct = total ? ((r.wins / total) * 100).toFixed(1) : "‚Äî";
        return { name: p.name, wins: r.wins, losses: r.losses, winPct };
      }).sort((a, b) => (b.wins - a.wins) || (a.losses - b.losses));

      let html = '<div class="record-table small-text">';
      html += `<div style="margin-bottom:0.25rem;">${labelText}</div>`;
      html += "<table><thead><tr><th>Player</th><th>W</th><th>L</th><th>Win%</th></tr></thead><tbody>";
      rows.forEach(r => {
        html += `<tr>
          <td>${r.name}</td>
          <td>${r.wins}</td>
          <td>${r.losses}</td>
          <td>${r.winPct === "‚Äî" ? "‚Äî" : r.winPct + "%"}</td>
        </tr>`;
      });
      html += "</tbody></table></div>";

      container.innerHTML = html;
    }

    // ---------- UI renderers ----------
    function renderPlayersTable() {
      const wrapper = document.getElementById("playersTableWrapper");
      if (!wrapper) return;

      if (!players.length) {
        wrapper.innerHTML = '<div class="small-text">Add players above to get started.</div>';
        return;
      }

      const sorted = [...players].sort((a, b) => (b.rating || 0) - (a.rating || 0));
      const leaderId = sorted.length ? sorted[0].id : null;

      let html = "<table><thead><tr><th>Name</th><th>Rating</th><th>Games</th><th></th></tr></thead><tbody>";
      sorted.forEach(p => {
        const numGames = games.filter(g => g.participants.includes(p.id)).length;
        const displayName = p.id === leaderId ? `üëë ${p.name}` : p.name;
        html += `<tr>
          <td>${displayName}</td>
          <td class="rating">${Math.round(p.rating)}</td>
          <td>${numGames}</td>
          <td><button class="secondary" data-remove-player="${p.id}">Remove</button></td>
        </tr>`;
      });
      html += "</tbody></table>";
      wrapper.innerHTML = html;

      wrapper.querySelectorAll("button[data-remove-player]").forEach(btn => {
        btn.addEventListener("click", async () => {
          const id = btn.getAttribute("data-remove-player");
          if (!confirm("Remove this player from Firestore? Existing games will still reference them.")) return;
          await deleteDoc(doc(db, "players", id));
        });
      });
    }

    function renderRatingsTable() {
      const wrapper = document.getElementById("ratingsTableWrapper");
      if (!wrapper) return;

      if (!players.length) {
        wrapper.innerHTML = '<div class="small-text">No players yet.</div>';
        return;
      }

      const sorted = [...players].sort((a, b) => (b.rating || 0) - (a.rating || 0));
      const leaderId = sorted.length ? sorted[0].id : null;

      let html = "<table><thead><tr><th>#</th><th>Name</th><th>Rating</th><th>Games</th></tr></thead><tbody>";
      sorted.forEach((p, idx) => {
        const numGames = games.filter(g => g.participants.includes(p.id)).length;
        const displayName = p.id === leaderId ? `üëë ${p.name}` : p.name;
        html += `<tr>
          <td>${idx + 1}</td>
          <td>${displayName}</td>
          <td class="rating">${Math.round(p.rating)}</td>
          <td>${numGames}</td>
        </tr>`;
      });
      html += "</tbody></table>";
      wrapper.innerHTML = html;
    }

    function renderGamePlayersForm() {
      const section = document.getElementById("gamePlayersSection");
      if (!section) return;

      if (players.length < 2) {
        section.innerHTML = '<div class="small-text danger">You need at least 2 players to log a game.</div>';
        return;
      }

      const playerOptions = players.map(p => `<option value="${p.id}">${p.name}</option>`).join("");

      section.innerHTML = `
        <div class="row">
          <div class="field inline" style="max-width:200px;">
            <label>Game type</label>
            <select id="gameType">
              <option value="2">2 players</option>
              <option value="3">3 players</option>
            </select>
          </div>
        </div>
        <div id="gameTypeFields" style="margin-top:0.5rem;"></div>
      `;

      const fields = section.querySelector("#gameTypeFields");
      const gameTypeSelect = section.querySelector("#gameType");

      function renderFields() {
        const type = gameTypeSelect.value;
        if (type === "2") {
          fields.innerHTML = `
            <div class="row">
              <div class="field">
                <label>Winner</label>
                <select id="slotWinner">
                  <option value="">-- select winner --</option>
                  ${playerOptions}
                </select>
              </div>
              <div class="field">
                <label>Loser</label>
                <select id="slotLoser">
                  <option value="">-- select loser --</option>
                  ${playerOptions}
                </select>
              </div>
            </div>
          `;
        } else {
          fields.innerHTML = `
            <div class="row">
              <div class="field">
                <label>1st</label>
                <select id="slotFirst">
                  <option value="">-- select 1st --</option>
                  ${playerOptions}
                </select>
              </div>
              <div class="field">
                <label>2nd</label>
                <select id="slotSecond">
                  <option value="">-- select 2nd --</option>
                  ${playerOptions}
                </select>
              </div>
              <div class="field">
                <label>3rd</label>
                <select id="slotThird">
                  <option value="">-- select 3rd --</option>
                  ${playerOptions}
                </select>
              </div>
            </div>
          `;
        }
      }

      gameTypeSelect.addEventListener("change", renderFields);
      renderFields();
    }

    // ---------- History tab content ----------
    function buildAllGamesTableHtml(filteredGames) {
      if (!filteredGames.length) return '<div class="small-text">No games in this season yet.</div>';

      const sorted = [...filteredGames].sort((a, b) => (b.date || "").localeCompare(a.date || ""));

      let html = "<table><thead><tr><th>Date</th><th>Result</th><th>Players</th><th></th></tr></thead><tbody>";

      sorted.forEach(game => {
        const placementsSorted = [...game.placements].sort((a, b) => a.rank - b.rank);

        const p1 = placementsSorted.find(pl => pl.rank === 1);
        const p2 = placementsSorted.find(pl => pl.rank === 2);
        const p3 = placementsSorted.find(pl => pl.rank === 3);

        const n = game.participants.length;

        const name1 = p1 ? (getPlayerById(p1.playerId)?.name || "Unknown") : "Unknown";
        const name2 = p2 ? (getPlayerById(p2.playerId)?.name || "Unknown") : null;
        const name3 = p3 ? (getPlayerById(p3.playerId)?.name || "Unknown") : null;

        let resultText = n === 2 ? `Winner: ${name1}` : `1st: ${name1}`;

        const playersList = [];
        if (n === 2) {
          playersList.push(`üèÜ ${name1}`);
          if (name2) playersList.push(`üíÄ ${name2}`);
        } else {
          if (name1) playersList.push(`ü•á ${name1}`);
          if (name2) playersList.push(`ü•à ${name2}`);
          if (name3) playersList.push(`ü•â ${name3}`);
        }

        html += `<tr>
          <td>${formatDate(game.date)}</td>
          <td><span class="tag-pill pill-win">${resultText}</span></td>
          <td class="game-players">${playersList.join("<br/>")}</td>
          <td><button class="secondary" data-delete-game="${game.id}">Delete</button></td>
        </tr>`;
      });

      html += "</tbody></table>";
      return html;
    }

    // Head-to-head: ONLY 2-player games (no 3-player leakage)
    function buildHeadToHeadHtml(playerAId, playerBId, filteredGames) {
      const playerA = getPlayerById(playerAId);
      const playerB = getPlayerById(playerBId);
      if (!playerA || !playerB) return '<div class="small-text">Players not found.</div>';

      const relevantGames = filteredGames.filter(g =>
        g.participants.length === 2 &&
        g.participants.includes(playerAId) &&
        g.participants.includes(playerBId)
      );

      if (!relevantGames.length) {
        return `<div class="small-text">No 2-player games with both ${playerA.name} and ${playerB.name} in this season.</div>`;
      }

      let winsA = 0, winsB = 0;

      relevantGames.forEach(game => {
        const rankA = game.placements.find(pl => pl.playerId === playerAId)?.rank ?? 999;
        const rankB = game.placements.find(pl => pl.playerId === playerBId)?.rank ?? 999;
        if (rankA < rankB) winsA++;
        else if (rankB < rankA) winsB++;
      });

      return `
        <div class="small-text">2-player games this season: ${relevantGames.length}</div>
        <div class="tally-row"><span class="tally-label">${playerA.name} wins:</span><span>${winsA}</span></div>
        <div class="tally-row"><span class="tally-label">${playerB.name} wins:</span><span>${winsB}</span></div>
      `;
    }

    // 3-player tab: show 1st/2nd/3rd counts per player
    function buildThreePlayerStatsHtml(filteredGames) {
      const threeGames = filteredGames.filter(g => g.participants.length === 3);
      if (!threeGames.length) return '<div class="small-text">No 3-player games in this season.</div>';

      const counts = {};
      players.forEach(p => counts[p.id] = { first: 0, second: 0, third: 0 });

      threeGames.forEach(game => {
        game.placements.forEach(pl => {
          if (!counts[pl.playerId]) counts[pl.playerId] = { first: 0, second: 0, third: 0 };
          if (pl.rank === 1) counts[pl.playerId].first++;
          else if (pl.rank === 2) counts[pl.playerId].second++;
          else if (pl.rank === 3) counts[pl.playerId].third++;
        });
      });

      let html = `<div class="small-text">Total 3-player games this season: ${threeGames.length}</div>`;
      html += "<table style='margin-top:0.5rem;'><thead><tr><th>Player</th><th>ü•á</th><th>ü•à</th><th>ü•â</th></tr></thead><tbody>";

      players.forEach(p => {
        const c = counts[p.id] || { first: 0, second: 0, third: 0 };
        html += `<tr><td>${p.name}</td><td>${c.first}</td><td>${c.second}</td><td>${c.third}</td></tr>`;
      });

      html += "</tbody></table>";
      return html;
    }

    function renderHistory() {
      const wrapper = document.getElementById("gamesTableWrapper");
      if (!wrapper) return;

      const badge = document.getElementById("gamesCountBadge");
      if (badge) badge.textContent = `${games.length} game${games.length === 1 ? "" : "s"} logged`;

      if (!games.length) {
        wrapper.innerHTML = '<div class="small-text">No games yet ‚Äì log your first one above.</div>';
        return;
      }

      const seasonSet = new Set();
      games.forEach(g => seasonSet.add(getSeasonKey(g.date)));
      const seasons = Array.from(seasonSet).sort();

      const filteredGames = currentSeasonFilter === "all"
        ? games
        : games.filter(g => getSeasonKey(g.date) === currentSeasonFilter);

      let html = "";
      html += '<div class="season-filter-row">';
      html += '<label for="seasonFilter">Season:</label>';
      html += '<select id="seasonFilter" class="season-select">';
      html += `<option value="all"${currentSeasonFilter === "all" ? " selected" : ""}>All seasons</option>`;
      seasons.forEach(sk => {
        html += `<option value="${sk}"${currentSeasonFilter === sk ? " selected" : ""}>${sk}</option>`;
      });
      html += "</select>";
      html += "</div>";

      if (!filteredGames.length) {
        html += '<div class="small-text">No games in this season yet.</div>';
        wrapper.innerHTML = html;
        const sel = wrapper.querySelector("#seasonFilter");
        sel.addEventListener("change", () => {
          currentSeasonFilter = sel.value;
          renderRecordBlock();
          renderHistory();
        });
        return;
      }

      // Tabs
      const tabs = [{ id: "all", label: "All games" }];

      for (let i = 0; i < players.length; i++) {
        for (let j = i + 1; j < players.length; j++) {
          tabs.push({
            id: `pair:${players[i].id}:${players[j].id}`,
            label: `${players[i].name} vs ${players[j].name}`
          });
        }
      }

      const hasThree = filteredGames.some(g => g.participants.length === 3);
      if (hasThree) tabs.push({ id: "three", label: "3-player games" });

      if (!tabs.find(t => t.id === currentHistoryTab)) currentHistoryTab = "all";

      html += '<div class="tabs">';
      tabs.forEach(t => {
        const active = t.id === currentHistoryTab ? "tab-active" : "";
        html += `<button class="tab ${active}" data-tab-id="${t.id}">${t.label}</button>`;
      });
      html += '</div><div id="historyInner"></div>';

      wrapper.innerHTML = html;

      const sel = wrapper.querySelector("#seasonFilter");
      sel.addEventListener("change", () => {
        currentSeasonFilter = sel.value;
        renderRecordBlock();
        renderHistory();
      });

      wrapper.querySelectorAll(".tab").forEach(btn => {
        btn.addEventListener("click", () => {
          currentHistoryTab = btn.getAttribute("data-tab-id");
          renderHistory();
        });
      });

      const inner = document.getElementById("historyInner");
      if (!inner) return;

      if (currentHistoryTab === "all") {
        inner.innerHTML = buildAllGamesTableHtml(filteredGames);
        inner.querySelectorAll("button[data-delete-game]").forEach(btn => {
          btn.addEventListener("click", async () => {
            const id = btn.getAttribute("data-delete-game");
            if (!confirm("Delete this game? Ratings will be recalculated.")) return;
            await deleteDoc(doc(db, "games", id));
          });
        });
      } else if (currentHistoryTab === "three") {
        inner.innerHTML = buildThreePlayerStatsHtml(filteredGames);
      } else if (currentHistoryTab.startsWith("pair:")) {
        const [_, aId, bId] = currentHistoryTab.split(":");
        inner.innerHTML = buildHeadToHeadHtml(aId, bId, filteredGames);
      }
    }

    // ---------- Weekly ELO chart ----------
    function renderEloChart() {
      const wrapper = document.getElementById("eloChartWrapper");
      if (!wrapper) return;

      if (!games.length || !ratingTimeline.length || !players.length) {
        wrapper.innerHTML = '<div class="small-text">ELO chart will appear after you log some games.</div>';
        if (eloChartInstance) { eloChartInstance.destroy(); eloChartInstance = null; }
        return;
      }

      // keep last snapshot per week
      const weeklyMap = {};
      ratingTimeline.forEach(pt => {
        const { key, label } = getWeekKeyAndLabel(pt.date);
        weeklyMap[key] = { key, label, ratings: pt.ratings };
      });

      const weekKeys = Object.keys(weeklyMap).sort();
      const weeklyTimeline = weekKeys.map(k => weeklyMap[k]);

      const labels = weeklyTimeline.map(pt => pt.label);
      const datasets = players.map(p => ({
        label: p.name,
        data: weeklyTimeline.map(pt => pt.ratings[p.id] !== undefined ? Math.round(pt.ratings[p.id]) : null),
        borderWidth: 2,
        tension: 0.2,
        spanGaps: true
      }));

      wrapper.innerHTML = '<canvas id="eloChartCanvas"></canvas>';
      const ctx = document.getElementById("eloChartCanvas").getContext("2d");
      if (eloChartInstance) eloChartInstance.destroy();

      eloChartInstance = new Chart(ctx, {
        type: "line",
        data: { labels, datasets },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: { title: { display: true, text: "ELO rating" } },
            x: { title: { display: true, text: "Week" } }
          },
          plugins: {
            legend: { display: true, labels: { boxWidth: 12 } }
          }
        }
      });
    }

    // ---------- Render all ----------
    function renderAll() {
      renderPlayersTable();
      renderRatingsTable();
      renderGamePlayersForm();
      renderRecordBlock();
      renderHistory();
      renderEloChart();

      const kInput = document.getElementById("kFactor");
      if (kInput) kInput.value = settings.kFactor ?? 32;
    }

    // ---------- Firestore subscriptions ----------
    function subscribeToFirestore() {
      onSnapshot(playersCol, snap => {
        players = snap.docs.map(d => ({ id: d.id, ...d.data() }));
        recalculateRatingsFromScratch();
        renderAll();
      });

      onSnapshot(gamesCol, snap => {
        games = snap.docs.map(d => ({ id: d.id, ...d.data() }));
        recalculateRatingsFromScratch();
        renderAll();
      });

      onSnapshot(settingsDocRef, async docSnap => {
        if (!docSnap.exists()) {
          await setDoc(settingsDocRef, { kFactor: 32 });
          settings = { kFactor: 32 };
        } else {
          settings = { kFactor: docSnap.data().kFactor ?? 32 };
        }
        recalculateRatingsFromScratch();
        renderAll();
      });
    }

    // ---------- Reset ----------
    async function resetAllData() {
      if (!confirm("This will delete ALL players, games, and settings from Firestore. Continue?")) return;

      const ps = await getDocs(playersCol);
      await Promise.all(ps.docs.map(d => deleteDoc(d.ref)));

      const gs = await getDocs(gamesCol);
      await Promise.all(gs.docs.map(d => deleteDoc(d.ref)));

      await setDoc(settingsDocRef, { kFactor: 32 });
    }

    // ---------- Handlers ----------
    function setupEventHandlers() {
      const addPlayerBtn = document.getElementById("addPlayerBtn");
      const newPlayerNameInput = document.getElementById("newPlayerName");
      const startingRatingInput = document.getElementById("startingRating");
      const addGameBtn = document.getElementById("addGameBtn");
      const kFactorInput = document.getElementById("kFactor");
      const resetAllBtn = document.getElementById("resetAllBtn");
      const gameDateInput = document.getElementById("gameDate");

      if (gameDateInput) gameDateInput.value = new Date().toISOString().slice(0, 10);

      if (addPlayerBtn) {
        addPlayerBtn.addEventListener("click", async () => {
          const name = (newPlayerNameInput?.value || "").trim();
          let rating = Number(startingRatingInput?.value);
          if (!name) return alert("Enter a player name.");
          if (!Number.isFinite(rating)) rating = 1500;

          await addDoc(playersCol, { name, startingRating: rating });
          if (newPlayerNameInput) newPlayerNameInput.value = "";
        });
      }

      if (kFactorInput) {
        kFactorInput.addEventListener("change", async () => {
          let k = Number(kFactorInput.value);
          if (!Number.isFinite(k) || k <= 0) k = 32;
          await setDoc(settingsDocRef, { kFactor: k }, { merge: true });
        });
      }

      if (resetAllBtn) resetAllBtn.addEventListener("click", resetAllData);

      if (addGameBtn) {
        addGameBtn.addEventListener("click", async () => {
          const date = document.getElementById("gameDate")?.value || new Date().toISOString().slice(0, 10);
          const gameType = document.getElementById("gameType")?.value || "2";

          let placements = [];
          let participants = [];

          if (gameType === "2") {
            const winnerId = document.getElementById("slotWinner")?.value;
            const loserId = document.getElementById("slotLoser")?.value;

            if (!winnerId || !loserId) return alert("Pick a winner and a loser.");
            if (winnerId === loserId) return alert("Winner and loser must be different.");

            placements = [
              { playerId: winnerId, rank: 1 },
              { playerId: loserId, rank: 2 }
            ];
            participants = [winnerId, loserId];
          } else {
            const firstId = document.getElementById("slotFirst")?.value;
            const secondId = document.getElementById("slotSecond")?.value;
            const thirdId = document.getElementById("slotThird")?.value;

            if (!firstId || !secondId || !thirdId) return alert("Pick 1st, 2nd, and 3rd.");

            const chosen = [firstId, secondId, thirdId];
            const unique = new Set(chosen);
            if (unique.size !== 3) return alert("1st, 2nd, and 3rd must be different players.");

            placements = [
              { playerId: firstId, rank: 1 },
              { playerId: secondId, rank: 2 },
              { playerId: thirdId, rank: 3 }
            ];
            participants = chosen;
          }

          await addDoc(gamesCol, { date, placements, participants });
        });
      }
    }

    // ---------- Init ----------
    document.addEventListener("DOMContentLoaded", () => {
      setupEventHandlers();
      subscribeToFirestore();
    });
  </script>
  <div style="text-align:center; margin: 1.25rem 0 0.25rem;">
  <img
    src="./ChatGPT Image Dec 27, 2025, 03_02_49 PM.png"
    alt="Footer image"
    style="width:240px; height:auto; opacity:0.9;"
  />
</div>
</body>
</html>
